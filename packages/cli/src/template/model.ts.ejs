// Auto-generated , DO NOT EDIT
import {Entity, FunctionPropertyNames, FieldsExpression, GetOptions } from "@subql/types-core";
import assert from 'assert';
<%if (props.importJsonInterfaces.length !== 0) { %>
import { <% props.importJsonInterfaces.forEach(function(interface){ %>
    <%= interface %>,
<% }); %>} from '../interfaces';
<% } %>
<%if (props.importEnums.length !== 0) { %>
import {<% props.importEnums.forEach(function(e){ %>
    <%= e %>,
<% }); %>} from '../enums';<% } %>

export type <%= props.className %>Props = Omit<<%=props.className %>, NonNullable<FunctionPropertyNames<<%=props.className %>>> | '_name'>;

export class <%= props.className %> implements Entity {

    constructor(
        <% props.fields.forEach(function(field) { if (field.required) { %>
        <%= field.name %>: <%= field.type %><%= field.isArray ? "[]" : "" %>,<% } %><% }) %>
    ) {
        <% props.fields.filter(function(field) {return field.required === true;}).forEach(function(requiredField) { %>this.<%= requiredField.name %> = <%= requiredField.name %>;
        <% }) %>
    }

    <% props.fields.forEach(function(field){ %>public <%= field.name %><%= field.required ? "" : "?" %>: <%= field.type %><%= field.isArray ? "[]" : "" %>;
    <% }); %>

    get _name(): string {
        return '<%=props.entityName %>';
    }

    async save(): Promise<void> {
        let id = this.id;
        assert(id !== null, "Cannot save <%=props.className %> entity without an ID");
        await store.set('<%=props.entityName %>', id.toString(), this);
    }

    static async remove(id: string): Promise<void> {
        assert(id !== null, "Cannot remove <%=props.className %> entity without an ID");
        await store.remove('<%=props.entityName %>', id.toString());
    }

    static async get(id: string): Promise<<%=props.className %> | undefined> {
        assert((id !== null && id !== undefined), "Cannot get <%=props.className %> entity without an ID");
        const record = await store.get('<%=props.entityName %>', id.toString());
        if (record) {
            return this.create(record as <%= props.className %>Props);
        } else {
            return;
        }
    }
<% props.indexedFields.forEach(function(field){ %>
    <% if (field.unique) {%>

    static async getBy<%=helper.upperFirst(field.name) %>(<%=field.name %>: <%=field.type %>): Promise<<%=props.className %> | undefined> {
        const record = await store.getOneByField('<%=props.entityName %>', '<%=field.name %>', <%=field.name %>);
        if (record) {
            return this.create(record as <%= props.className %>Props);
        } else {
            return;
        }
    }
    <% } else { %>static async getBy<%=helper.upperFirst(field.name) %>(<%=field.name %>: <%=field.type %>, options: GetOptions<<%=props.className %>>): Promise<<%=props.className %>[]> {
        const records = await store.getByField<<%=props.className %>>('<%=props.entityName %>', '<%=field.name %>', <%=field.name %>, options);
        return records.map(record => this.create(record as <%= props.className %>Props));
    }
    <% }%>
<% }); %>

    /**
     * Gets entities matching the specified filters and options.
     *
     * ⚠️ This function will first search cache data followed by DB data. Please consider this when using order and offset options.⚠️
     * */
    static async getByFields(filter: FieldsExpression<<%= props.className %>Props>[], options: GetOptions<<%= props.className %>Props>): Promise<<%=props.className %>[]> {
        const records = await store.getByFields<<%=props.className %>>('<%=props.entityName %>', filter, options);
        return records.map(record => this.create(record as <%= props.className %>Props));
    }

    static create(record: <%= props.className %>Props): <%=props.className %> {
        assert(typeof record.id === 'string', "id must be provided");
        let entity = new this(
        <% props.fields.filter(function(field) {return field.required === true;}).forEach(function(requiredField) { %>    record.<%= requiredField.name %>,
        <% }) %>);
        Object.assign(entity,record);
        return entity;
    }
}
